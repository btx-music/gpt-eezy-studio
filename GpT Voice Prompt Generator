# 🔊 GPTeezy Voice Prompt Generator
import streamlit as st
from datetime import datetime
import os
import glob
import shutil
import pyperclip

# 🎧 Preset Styles
def get_voice_prompt(style):
    prompts = {
        "dreamy": "Soft male AI voice, slight glitch effect, digital warmth, whispery tone, emotional inflections – suitable for dreamy RnB ballads or cyber love songs.",
        "funky": "Energetic funky male voice, talkbox-inspired, playful with rhythm, retro-futuristic flair – great for NuDisco and FunkHop.",
        "clubby": "Deep robotic voice with punch, heavy reverb and tight delay, confident delivery – perfect for dancefloor anthems.",
        "emotional": "Cracked emotional tone, breathy delivery, occasional voice breaks, intimate feel – ideal for heartbreak ballads or lo-fi confessions.",
        "cyber": "Synthetic glitchy AI voice, metallic layer, smooth compression, layered with vocoder FX – tailored for futuristic or dystopian vibes."
    }
    return prompts.get(style, "Natural AI voice with standard tone and clarity.")

# 🌐 Streamlit UI
st.title("🔊 GPTeezy Voice Prompt Generator")

style = st.selectbox("🎻 Wähle deinen Style", ["dreamy", "funky", "clubby", "emotional", "cyber"])

# 🔧 Prompt Builder – Erweitertes Tool
with st.expander("🔧 Erweitertes Prompt Builder Tool"):
    voice_type = st.selectbox("👤 Stimme", ["Soft male", "Energetic male", "Deep robotic", "Breathy female", "Glitchy AI"])
    tone = st.selectbox("🎙️ Tonlage", ["Whispery", "Playful", "Confident", "Emotional", "Metallic"])
    fx = st.multiselect("🎛️ Effekte", ["Reverb", "Delay", "Glitch", "Compression", "Vocoder", "Distortion"])
    application = st.text_input("🧠 Einsatzzweck", placeholder="z.B. für Love Songs, Clubtracks, Lofi...")

    builder_notes = f"{voice_type} voice, {tone.lower()} tone"
    if fx:
        builder_notes += f", with {' and '.join(fx)} effects"
    if application:
        builder_notes += f" – suitable for {application}"

    st.markdown("🪄 **Zusammenfassung:**")
    st.code(builder_notes)

    if st.button("🧩 Zusatz übernehmen"):
        st.session_state["custom_note"] = st.session_state.get("custom_note", "") + "\n" + builder_notes

# 📌 Textfeld mit Session State füllen
if "custom_note" not in st.session_state:
    st.session_state["custom_note"] = ""

custom_note = st.text_area("📝 Zusatz (optional)", value=st.session_state["custom_note"])

if st.button("🎤 Prompt generieren"):
    base_prompt = get_voice_prompt(style)
    if custom_note:
        base_prompt += f" Additional notes: {custom_note}"

    st.markdown("---")
    st.subheader("📄 Finaler Voice Prompt")
    st.code(base_prompt)

    # 📎 Save to file
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    filename = f"voice_prompt_{style}_{timestamp}.txt"
    folder = "VoicePrompts"
    os.makedirs(folder, exist_ok=True)
    full_path = os.path.join(folder, filename)

    with open(full_path, "w", encoding="utf-8") as f:
        f.write(base_prompt)

    st.success(f"✅ Prompt gespeichert unter: {full_path}")

    # 🔢 Copy to clipboard
    pyperclip.copy(base_prompt)
    st.info("🔹 Prompt wurde in die Zwischenablage kopiert.")

    # 📃 Optional Backup
    backup_folder = os.path.join(folder, "Backup")
    os.makedirs(backup_folder, exist_ok=True)
    backup_path = os.path.join(backup_folder, filename)
    shutil.copy(full_path, backup_path)
    st.info(f"🔹 Backup gespeichert unter: {backup_path}")

    # 💾 Direkt-Download im Browser anbieten
    with open(full_path, "r", encoding="utf-8") as f:
        st.download_button(
            label="📥 Prompt als .txt herunterladen",
            data=f.read(),
            file_name=filename,
            mime="text/plain"
        )

# 🧐 Prompt History mit Filter- und Exportfunktion
st.markdown("---")
st.subheader("📚 Voice Prompt History & Batch Export")

search_style = st.selectbox("🔎 Filter nach Style (optional)", ["", "dreamy", "funky", "clubby", "emotional", "cyber"])
search_keyword = st.text_input("🔤 Suchbegriff (optional)", placeholder="z.B. German, glitchy, vocoder…")

prompt_files = sorted(glob.glob("VoicePrompts/*.txt"), reverse=True)[:100]

matches = []
for file in prompt_files:
    with open(file, "r", encoding="utf-8") as f:
        content = f.read()
        filename = os.path.basename(file)
        if (not search_style or search_style in filename) and (not search_keyword or search_keyword.lower() in content.lower()):
            matches.append((filename, content, file))

selected_files = []

if matches:
    for filename, content, path in matches:
        with st.expander(f"📝 {filename}"):
            st.code(content)
            col1, col2, col3 = st.columns([1,1,2])
            with col1:
                if st.button("📋 Kopieren", key=f"copy_{filename}"):
                    pyperclip.copy(content)
                    st.success("🔹 In Zwischenablage kopiert!")
            with col2:
                st.download_button("⬇️ Download", data=content, file_name=filename, mime="text/plain", key=f"dl_{filename}")
            with col3:
                if st.checkbox("🧷 Zur ZIP-Auswahl", key=f"select_{filename}"):
                    selected_files.append(path)
else:
    st.info("Keine Prompts gefunden mit diesen Filtern.")

# 📦 Export ZIP bei Auswahl
if selected_files:
    if st.button("📦 Exportiere Auswahl als ZIP"):
        zip_name = f"selected_voice_prompts_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.zip"
        zip_path = os.path.join("VoicePrompts", zip_name)

        # ✅ Zip manuell erstellen
        import zipfile
        with zipfile.ZipFile(zip_path, 'w') as zipf:
            for file_path in selected_files:
                arcname = os.path.basename(file_path)
                zipf.write(file_path, arcname=arcname)

        with open(zip_path, "rb") as f:
            st.download_button("📥 ZIP herunterladen", f.read(), file_name=zip_name, mime="application/zip")
# ✏️ Bestehenden Prompt bearbeiten
st.markdown("---")
st.subheader("✏️ Voice Prompt bearbeiten")

edit_file = st.selectbox("📂 Wähle eine Datei zum Bearbeiten", [""] + [f[0] for f in matches])
edited_content = ""

if edit_file and edit_file != "":
    # Hole den Inhalt der ausgewählten Datei
    for f, content, _ in matches:
        if f == edit_file:
            edited_content = content
            break
    # 🔁 Wenn eine alte Version wiederhergestellt wurde, diese übernehmen
    if "restored_content" in st.session_state:
        edited_content = st.session_state.pop("restored_content")


    # Prompt bearbeiten
    new_content = st.text_area("🧾 Bearbeite den Prompt", value=edited_content, height=300)

    col1, col2 = st.columns(2)

    with col1:
        if st.button("💾 Als neue Datei speichern"):
            new_name = f"{edit_file.replace('.txt','')}_edited_{datetime.now().strftime('%H-%M-%S')}.txt"
            new_path = os.path.join("VoicePrompts", new_name)
            with open(new_path, "w", encoding="utf-8") as f:
                f.write(new_content)
            st.success(f"✅ Neuer Prompt gespeichert: {new_name}")
            st.balloons()

# 📁 Backup-Ordner für Versioning
with col2:
    if st.button("♻️ Original überschreiben"):
        # 📁 Backup-Ordner vorbereiten
        backup_dir = os.path.join("VoicePrompts", "_backups", edit_file.replace(".txt", ""))
        os.makedirs(backup_dir, exist_ok=True)

        # 🕒 Alte Version sichern
        backup_filename = f"{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.txt"
        backup_full_path = os.path.join(backup_dir, backup_filename)
        with open(backup_full_path, "w", encoding="utf-8") as f:
            f.write(edited_content)  # Inhalt vor Änderung sichern

        # 🔄 Überschreiben der Originaldatei
        overwrite_path = os.path.join("VoicePrompts", edit_file)
        with open(overwrite_path, "w", encoding="utf-8") as f:
            f.write(new_content)

        st.success(f"✅ Original-Prompt überschrieben: {edit_file}")
        st.balloons()

# 🔎 Zeige alte Versionen an
st.markdown("### 🔁 Alte Versionen")
backup_files = sorted(glob.glob(os.path.join(backup_dir, "*.txt")), reverse=True)

for bfile in backup_files:
    with open(bfile, "r", encoding="utf-8") as f:
        bcontent = f.read()
    
    with st.expander(f"📜 {os.path.basename(bfile)}"):
        st.code(bcontent)
        
        col_restore, col_save = st.columns(2)
        with col_restore:
            if st.button(f"🕹️ Wiederherstellen", key=f"restore_{bfile}"):
                st.session_state["restored_content"] = bcontent
                st.success(f"✅ Version {os.path.basename(bfile)} wurde in den Editor geladen")

        with col_save:
            st.download_button("📥 Download", data=bcontent, file_name=os.path.basename(bfile), mime="text/plain", key=f"dl_{bfile}")
