# ğŸ”Š GPTeezy Voice Prompt Generator
import streamlit as st
from datetime import datetime
import os
import glob
import shutil
import pyperclip

# ğŸ§ Preset Styles
def get_voice_prompt(style):
    prompts = {
        "dreamy": "Soft male AI voice, slight glitch effect, digital warmth, whispery tone, emotional inflections â€“ suitable for dreamy RnB ballads or cyber love songs.",
        "funky": "Energetic funky male voice, talkbox-inspired, playful with rhythm, retro-futuristic flair â€“ great for NuDisco and FunkHop.",
        "clubby": "Deep robotic voice with punch, heavy reverb and tight delay, confident delivery â€“ perfect for dancefloor anthems.",
        "emotional": "Cracked emotional tone, breathy delivery, occasional voice breaks, intimate feel â€“ ideal for heartbreak ballads or lo-fi confessions.",
        "cyber": "Synthetic glitchy AI voice, metallic layer, smooth compression, layered with vocoder FX â€“ tailored for futuristic or dystopian vibes."
    }
    return prompts.get(style, "Natural AI voice with standard tone and clarity.")

# ğŸŒ Streamlit UI
st.title("ğŸ”Š GPTeezy Voice Prompt Generator")

style = st.selectbox("ğŸ» WÃ¤hle deinen Style", ["dreamy", "funky", "clubby", "emotional", "cyber"])

# ğŸ”§ Prompt Builder â€“ Erweitertes Tool
with st.expander("ğŸ”§ Erweitertes Prompt Builder Tool"):
    voice_type = st.selectbox("ğŸ‘¤ Stimme", ["Soft male", "Energetic male", "Deep robotic", "Breathy female", "Glitchy AI"])
    tone = st.selectbox("ğŸ™ï¸ Tonlage", ["Whispery", "Playful", "Confident", "Emotional", "Metallic"])
    fx = st.multiselect("ğŸ›ï¸ Effekte", ["Reverb", "Delay", "Glitch", "Compression", "Vocoder", "Distortion"])
    application = st.text_input("ğŸ§  Einsatzzweck", placeholder="z.B. fÃ¼r Love Songs, Clubtracks, Lofi...")

    builder_notes = f"{voice_type} voice, {tone.lower()} tone"
    if fx:
        builder_notes += f", with {' and '.join(fx)} effects"
    if application:
        builder_notes += f" â€“ suitable for {application}"

    st.markdown("ğŸª„ **Zusammenfassung:**")
    st.code(builder_notes)

    if st.button("ğŸ§© Zusatz Ã¼bernehmen"):
        st.session_state["custom_note"] = st.session_state.get("custom_note", "") + "\n" + builder_notes

# ğŸ“Œ Textfeld mit Session State fÃ¼llen
if "custom_note" not in st.session_state:
    st.session_state["custom_note"] = ""

custom_note = st.text_area("ğŸ“ Zusatz (optional)", value=st.session_state["custom_note"])

if st.button("ğŸ¤ Prompt generieren"):
    base_prompt = get_voice_prompt(style)
    if custom_note:
        base_prompt += f" Additional notes: {custom_note}"

    st.markdown("---")
    st.subheader("ğŸ“„ Finaler Voice Prompt")
    st.code(base_prompt)

    # ğŸ“ Save to file
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    filename = f"voice_prompt_{style}_{timestamp}.txt"
    folder = "VoicePrompts"
    os.makedirs(folder, exist_ok=True)
    full_path = os.path.join(folder, filename)

    with open(full_path, "w", encoding="utf-8") as f:
        f.write(base_prompt)

    st.success(f"âœ… Prompt gespeichert unter: {full_path}")

    # ğŸ”¢ Copy to clipboard
    pyperclip.copy(base_prompt)
    st.info("ğŸ”¹ Prompt wurde in die Zwischenablage kopiert.")

    # ğŸ“ƒ Optional Backup
    backup_folder = os.path.join(folder, "Backup")
    os.makedirs(backup_folder, exist_ok=True)
    backup_path = os.path.join(backup_folder, filename)
    shutil.copy(full_path, backup_path)
    st.info(f"ğŸ”¹ Backup gespeichert unter: {backup_path}")

    # ğŸ’¾ Direkt-Download im Browser anbieten
    with open(full_path, "r", encoding="utf-8") as f:
        st.download_button(
            label="ğŸ“¥ Prompt als .txt herunterladen",
            data=f.read(),
            file_name=filename,
            mime="text/plain"
        )

# ğŸ§ Prompt History mit Filter- und Exportfunktion
st.markdown("---")
st.subheader("ğŸ“š Voice Prompt History & Batch Export")

search_style = st.selectbox("ğŸ” Filter nach Style (optional)", ["", "dreamy", "funky", "clubby", "emotional", "cyber"])
search_keyword = st.text_input("ğŸ”¤ Suchbegriff (optional)", placeholder="z.B. German, glitchy, vocoderâ€¦")

prompt_files = sorted(glob.glob("VoicePrompts/*.txt"), reverse=True)[:100]

matches = []
for file in prompt_files:
    with open(file, "r", encoding="utf-8") as f:
        content = f.read()
        filename = os.path.basename(file)
        if (not search_style or search_style in filename) and (not search_keyword or search_keyword.lower() in content.lower()):
            matches.append((filename, content, file))

selected_files = []

if matches:
    for filename, content, path in matches:
        with st.expander(f"ğŸ“ {filename}"):
            st.code(content)
            col1, col2, col3 = st.columns([1,1,2])
            with col1:
                if st.button("ğŸ“‹ Kopieren", key=f"copy_{filename}"):
                    pyperclip.copy(content)
                    st.success("ğŸ”¹ In Zwischenablage kopiert!")
            with col2:
                st.download_button("â¬‡ï¸ Download", data=content, file_name=filename, mime="text/plain", key=f"dl_{filename}")
            with col3:
                if st.checkbox("ğŸ§· Zur ZIP-Auswahl", key=f"select_{filename}"):
                    selected_files.append(path)
else:
    st.info("Keine Prompts gefunden mit diesen Filtern.")

# ğŸ“¦ Export ZIP bei Auswahl
if selected_files:
    if st.button("ğŸ“¦ Exportiere Auswahl als ZIP"):
        zip_name = f"selected_voice_prompts_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.zip"
        zip_path = os.path.join("VoicePrompts", zip_name)

        # âœ… Zip manuell erstellen
        import zipfile
        with zipfile.ZipFile(zip_path, 'w') as zipf:
            for file_path in selected_files:
                arcname = os.path.basename(file_path)
                zipf.write(file_path, arcname=arcname)

        with open(zip_path, "rb") as f:
            st.download_button("ğŸ“¥ ZIP herunterladen", f.read(), file_name=zip_name, mime="application/zip")
# âœï¸ Bestehenden Prompt bearbeiten
st.markdown("---")
st.subheader("âœï¸ Voice Prompt bearbeiten")

edit_file = st.selectbox("ğŸ“‚ WÃ¤hle eine Datei zum Bearbeiten", [""] + [f[0] for f in matches])
edited_content = ""

if edit_file and edit_file != "":
    # Hole den Inhalt der ausgewÃ¤hlten Datei
    for f, content, _ in matches:
        if f == edit_file:
            edited_content = content
            break
    # ğŸ” Wenn eine alte Version wiederhergestellt wurde, diese Ã¼bernehmen
    if "restored_content" in st.session_state:
        edited_content = st.session_state.pop("restored_content")


    # Prompt bearbeiten
    new_content = st.text_area("ğŸ§¾ Bearbeite den Prompt", value=edited_content, height=300)

    col1, col2 = st.columns(2)

    with col1:
        if st.button("ğŸ’¾ Als neue Datei speichern"):
            new_name = f"{edit_file.replace('.txt','')}_edited_{datetime.now().strftime('%H-%M-%S')}.txt"
            new_path = os.path.join("VoicePrompts", new_name)
            with open(new_path, "w", encoding="utf-8") as f:
                f.write(new_content)
            st.success(f"âœ… Neuer Prompt gespeichert: {new_name}")
            st.balloons()

# ğŸ“ Backup-Ordner fÃ¼r Versioning
with col2:
    if st.button("â™»ï¸ Original Ã¼berschreiben"):
        # ğŸ“ Backup-Ordner vorbereiten
        backup_dir = os.path.join("VoicePrompts", "_backups", edit_file.replace(".txt", ""))
        os.makedirs(backup_dir, exist_ok=True)

        # ğŸ•’ Alte Version sichern
        backup_filename = f"{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.txt"
        backup_full_path = os.path.join(backup_dir, backup_filename)
        with open(backup_full_path, "w", encoding="utf-8") as f:
            f.write(edited_content)  # Inhalt vor Ã„nderung sichern

        # ğŸ”„ Ãœberschreiben der Originaldatei
        overwrite_path = os.path.join("VoicePrompts", edit_file)
        with open(overwrite_path, "w", encoding="utf-8") as f:
            f.write(new_content)

        st.success(f"âœ… Original-Prompt Ã¼berschrieben: {edit_file}")
        st.balloons()

# ğŸ” Zeige alte Versionen an
st.markdown("### ğŸ” Alte Versionen")
backup_files = sorted(glob.glob(os.path.join(backup_dir, "*.txt")), reverse=True)

for bfile in backup_files:
    with open(bfile, "r", encoding="utf-8") as f:
        bcontent = f.read()
    
    with st.expander(f"ğŸ“œ {os.path.basename(bfile)}"):
        st.code(bcontent)
        
        col_restore, col_save = st.columns(2)
        with col_restore:
            if st.button(f"ğŸ•¹ï¸ Wiederherstellen", key=f"restore_{bfile}"):
                st.session_state["restored_content"] = bcontent
                st.success(f"âœ… Version {os.path.basename(bfile)} wurde in den Editor geladen")

        with col_save:
            st.download_button("ğŸ“¥ Download", data=bcontent, file_name=os.path.basename(bfile), mime="text/plain", key=f"dl_{bfile}")
